<html><head><base href="."><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>Ultimate Tic Tac Toe</title>
<style>
body {
  display: flex;
  flex-direction: column;
  align-items: center;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
  background: #0d1117;
  color: #c9d1d9;
  perspective: 1000px;
  min-height: 100vh;
  margin: 0;
  padding: 20px;
  box-sizing: border-box;
  overflow: hidden;
}

@keyframes titleColorFade {
  0% {
    color: #ff7b72; /* X color */
  }
  50% {
    color: #58a6ff; /* O color */
  }
  100% {
    color: #ff7b72; /* Back to X color */
  }
}

/* Add this keyframe animation for tilting */
@keyframes titleTilt {
  0% {
    transform: rotate(-2deg);
  }
  50% {
    transform: rotate(2deg);
  }
  100% {
    transform: rotate(-2deg);
  }
}

@keyframes float {
  0% {
    transform: translateY(0) rotate(0deg);
  }
  50% {
    transform: translateY(-20px) rotate(180deg);
  }
  100% {
    transform: translateY(0) rotate(360deg);
  }
}

.particles-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: -1;
  overflow: hidden;
}

.particle {
  position: absolute;
  font-size: 40px;
  opacity: 0.15;
  animation: float 8s infinite ease-in-out;
}

.particle.x {
  color: #ff7b72;
}

.particle.o {
  color: #58a6ff;
}

h1 {
  color: #ff7b72;
  font-size: 32px;
  margin: 10px 0; /* Reduced margin */
  animation: 
    titleColorFade 4s ease-in-out infinite,
    titleTilt 6s ease-in-out infinite;
}

.difficulty-display {
  font-size: 14px;
  color: #8b949e;
  margin-bottom: 10px;
  text-align: center;
}

.game-layout {
  display: flex;
  gap: 20px;
  align-items: flex-start;
  justify-content: center;
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 20px;
  flex: 1;
  position: relative; /* Changed to relative */
}

.play-log {
  position: fixed;
  left: 20px;
  top: 20px;
  z-index: 100;
  max-height: calc(100vh - 40px); /* Limit height to viewport height minus margins */
  background: #161b22;
  padding: 15px;
  border-radius: 6px;
  border: 1px solid #30363d;
  min-width: 200px;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: #58a6ff #21262d;
}

.play-log::-webkit-scrollbar {
  width: 8px;
}

.play-log::-webkit-scrollbar-track {
  background: #21262d;
  border-radius: 4px;
}

.play-log::-webkit-scrollbar-thumb {
  background: #58a6ff;
  border-radius: 4px;
}

.play-log::-webkit-scrollbar-thumb:hover {
  background: #77b6ff;
}

.play-log h2 {
  color: #c9d1d9;
  font-size: 18px;
  margin: 0 0 15px 0;
}

.log-entry {
  padding: 8px;
  margin: 5px 0;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  border: 1px solid #30363d;
}

.log-entry:hover {
  background: #21262d;
}

.log-entry.x-move {
  color: #ff7b72;
}

.log-entry.o-move {
  color: #58a6ff;
}

.log-entry.new-game {
  color: #8b949e; /* GitHub-style gray */
}

.cell.highlight {
  background: rgba(240, 136, 62, 0.3) !important; /* Added !important to ensure highlighting works */
}

#game-container {
  transform: scale(0.9); /* Scale down slightly if needed */
  transform-origin: center center;
  background: #161b22;
  padding: 20px;
  border-radius: 6px;
  box-shadow: 0 0 20px rgba(0,0,0,0.3);
  margin: 0 auto;
  border: 1px solid #30363d;
  position: relative;
  flex-shrink: 0;
}

#status {
  font-size: 24px;
  margin: 10px 0; /* Reduced margin */
}

#status.x-turn {
  color: #ff7b72; /* Red for X's turn */
}

#status.o-turn {
  color: #58a6ff; /* Blue for O's turn */
}

#reset {
  padding: 10px 20px;
  font-size: 16px;
  background: #238636;
  color: #ffffff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  margin: 10px 0; /* Reduced margin */
  font-weight: 500;
}

#reset:hover {
  background: #2ea043;
}

.super-board {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
  background: #0d1117;
  padding: 10px;
  border-radius: 6px;
}

.sub-board {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 2px;
  background: #161b22;
  padding: 5px;
  border-radius: 6px;
  transition: transform 0.3s ease; /* Added transition */
  transform-style: preserve-3d;
  position: relative;
  min-height: 150px; /* Slightly reduced */
  min-width: 150px; /* Slightly reduced */
  border: 1px solid #30363d;
}

.sub-board.inactive:not(.flipping) {
  opacity: 0.3;
}

.sub-board.flipping {
  transform: rotateY(180deg);
}

.sub-board.flipping .cell {
  display: none;
}

.sub-board.game-over:not(.winner-line) {
  opacity: 0.5;
}

.cell {
  width: 45px; /* Slightly reduced */
  height: 45px; /* Slightly reduced */
  background: #21262d;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  font-weight: bold;
  cursor: pointer;
  border-radius: 6px;
  transition: background-color 0.3s;
  border: 1px solid #30363d;
}

.cell:hover {
  background: #30363d;
}

.cell.x {
  color: #ff7b72;
}

.cell.o {
  color: #58a6ff;
}

.cell.draw {
  color: #f0883e;
}

.winner-symbol {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 100px;
  font-weight: bold;
  transform: rotateY(180deg);
  background: #161b22;
  border-radius: 6px;
  transition: opacity 0.3s ease; /* Added transition */
}

.winner-symbol.x {
  color: #ff7b72;
}

.winner-symbol.o {
  color: #58a6ff;
}

.winner-symbol.draw {
  color: #f0883e;
}

.sub-board.won-x {
  background: rgba(255, 123, 114, 0.1);
}

.sub-board.won-o {
  background: rgba(88, 166, 255, 0.1);
}

.sub-board.won-draw {
  background: rgba(240, 136, 62, 0.1);
}

.sub-board.active {
  box-shadow: 0 0 10px rgba(88, 166, 255, 0.3);
}

.sub-board.winner-line {
  opacity: 1;
}

.difficulty-settings {
  margin-bottom: 20px;
}

.difficulty-settings label {
  display: block;
  margin-bottom: 10px;
  color: #c9d1d9;
}

.difficulty-select {
  padding: 8px 12px;
  font-size: 14px;
  background: #21262d;
  color: #c9d1d9;
  border: 1px solid #30363d;
  border-radius: 6px;
  cursor: pointer;
  width: 200px;
}

.difficulty-select option {
  background: #21262d;
  color: #c9d1d9;
}

.difficulty-select:focus {
  outline: none;
  border-color: #58a6ff;
}

.ai-thinking {
  position: fixed;
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  gap: 10px;
  background: #161b22;
  padding: 10px 15px;
  border-radius: 6px;
  border: 1px solid #30363d;
  color: #58a6ff;
  transition: opacity 0.3s ease;
  z-index: 1000;
}

.ai-thinking.fade-out {
  opacity: 0;
  pointer-events: none;
}

.spinner {
  width: 20px;
  height: 20px;
  border: 3px solid #21262d;
  border-top: 3px solid #58a6ff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(13, 17, 23, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

.modal-overlay.active {
  opacity: 1;
  pointer-events: auto;
}

.modal {
  background: #161b22;
  padding: 30px;
  border-radius: 8px;
  border: 1px solid #30363d;
  text-align: center;
  transform: scale(0.9);
  transition: transform 0.3s ease;
  position: relative;
}

.modal-overlay.active .modal {
  transform: scale(1);
}

.modal h2 {
  color: #c9d1d9;
  margin-bottom: 20px;
}

.start-button {
  padding: 12px 24px;
  font-size: 16px;
  background: #238636;
  color: #ffffff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 500;
  transition: background-color 0.2s ease;
}

.start-button:hover {
  background: #2ea043;
}

.close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  color: #c9d1d9;
  font-size: 20px;
  cursor: pointer;
  padding: 5px;
  line-height: 1;
  transition: color 0.2s ease;
}

.close-button:hover {
  color: #ff7b72;
}

.sub-board.flipping .cell {
  display: none;
}

.cell {
  width: 45px; /* Slightly reduced */
  height: 45px; /* Slightly reduced */
  background: #21262d;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  font-weight: bold;
  cursor: pointer;
  border-radius: 6px;
  transition: background-color 0.3s;
  border: 1px solid #30363d;
}

.settings-button {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: #21262d;
  border: 1px solid #30363d;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: transform 0.2s ease;
  z-index: 1000; /* Ensure it stays on top */
}

.settings-button:hover {
  transform: rotate(45deg);
}

.settings-button svg {
  width: 24px;
  height: 24px;
  fill: #c9d1d9;
}

.settings-modal .modal {
  min-width: 300px;
}

.setting-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 15px 0;
  border-bottom: 1px solid #30363d;
}

.setting-item:last-child {
  border-bottom: none;
}

.setting-label {
  display: flex;
  align-items: center;
  gap: 10px;
  color: #c9d1d9;
}

.setting-label svg {
  width: 20px;
  height: 20px;
  fill: #8b949e;
}

/* Toggle Switch Styles */
.toggle-switch {
  position: relative;
  width: 50px;
  height: 24px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #21262d;
  border: 1px solid #30363d;
  transition: .4s;
  border-radius: 34px;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 2px;
  bottom: 2px;
  background-color: #c9d1d9;
  transition: .4s;
  border-radius: 50%;
}

input:checked + .toggle-slider {
  background-color: #238636;
}

input:checked + .toggle-slider:before {
  transform: translateX(26px);
}

/* Add styles for the stats button */
.stats-button {
  position: fixed;
  bottom: 80px; /* Position above settings button */
  right: 20px;
  background: #21262d;
  border: 1px solid #30363d;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: transform 0.2s ease;
  z-index: 1000;
}

.stats-button:hover {
  transform: scale(1.1);
}

.stats-button svg {
  width: 24px;
  height: 24px;
  fill: #c9d1d9;
}

/* Add styles for stats modal content */
.stats-container {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.stat-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px;
  background: #21262d;
  border-radius: 6px;
  border: 1px solid #30363d;
}

.stat-label {
  color: #8b949e;
}

.stat-value {
  color: #c9d1d9;
  font-weight: bold;
  font-size: 18px;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
</head>
<body>
<div class="particles-container" id="particles-container"></div>
<h1>Ultimate Tic Tac Toe</h1>
<div id="difficulty-display" class="difficulty-display">Difficulty: Medium</div>
<div id="ai-thinking" class="ai-thinking fade-out">
  <div class="spinner"></div>
  <span>AI thinking...</span>
</div>
<div id="status" class="x-turn">X's Turn</div>
<div class="game-layout">
  <div class="play-log" style="max-height: calc(100vh - 200px);">
<h2>Play Log</h2>
<div id="log-entries"></div>
</div>
  <div id="game-container">
    <div class="super-board" id="super-board"></div>
  </div>
</div>
<button id="reset">New Game</button>

<button class="settings-button" id="settings-button">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.65.07-.97 0-.32-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65z"/>
  </svg>
</button>

<!-- Add stats button above settings button -->
<button class="stats-button" id="stats-button">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/>
  </svg>
</button>

<!-- Add stats modal -->
<div class="modal-overlay stats-modal" id="stats-modal">
  <div class="modal">
    <button class="close-button" id="close-stats-modal">×</button>
    <h2>User Statistics</h2>
    <div class="stats-container">
      <div class="stat-item">
        <span class="stat-label">Wins</span>
        <span class="stat-value" id="wins-count">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Losses</span>
        <span class="stat-value" id="losses-count">0</span>
      </div>
    </div>
  </div>
</div>

<div class="modal-overlay" id="new-game-modal">
  <div class="modal">
    <button class="close-button" id="close-modal">×</button>
    <h2>New Game</h2>
    <div class="difficulty-settings">
      <label for="difficulty">Select Difficulty:</label>
      <select id="difficulty" class="difficulty-select">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
        <option value="insane">Insane</option>
      </select>
    </div>
    <button class="start-button" id="start-game">Start Game</button>
  </div>
</div>

<div class="modal-overlay settings-modal" id="settings-modal">
  <div class="modal">
    <button class="close-button" id="close-settings-modal">×</button>
    <h2>Settings</h2>
    <div class="setting-item">
      <div class="setting-label">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M11.5,20L16.36,10.27H13V4L8,13.73H11.5V20M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2Z" />
        </svg>
        Enable Particles
      </div>
      <label class="toggle-switch">
        <input type="checkbox" id="particles-toggle" checked>
        <span class="toggle-slider"></span>
      </label>
    </div>
    <div class="setting-item">
      <div class="setting-label">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M3,3H21V5H3V3M3,7H21V9H3V7M3,11H21V13H3V11M3,15H21V17H3V15M3,19H21V21H3V19Z" />
        </svg>
        Display Play Log
      </div>
      <label class="toggle-switch">
        <input type="checkbox" id="playlog-toggle" checked>
        <span class="toggle-slider"></span>
      </label>
    </div>
  </div>
</div>

<script>
class SuperTicTacToe {
  constructor() {
    this.currentPlayer = 'X';
    this.superBoard = Array(9).fill().map(() => Array(9).fill(''));
    this.subBoardWinners = Array(9).fill('');
    this.activeBoard = -1;
    this.gameWinner = null;
    this.moveLog = [{
      text: "New game started",
      type: "new-game"
    }];
    this.aiThinkingIndicator = document.getElementById('ai-thinking');
    this.initialDifficulty = 'medium'; // Store initial difficulty
    this.difficulty = this.initialDifficulty;
    this.stats = this.loadStats();
    this.updateDifficultyDisplay(); // Add this line
    this.createBoard();
    this.createParticles(); // Add this line to create particles
    this.addEventListeners();
    this.updateMoveLog(); // Add this line to ensure the log is displayed immediately
    this.initializeSettings(); // Initialize settings functionality
    this.updateStatsDisplay(); // Add this line to initially show stats
    this.initializeStatsModal(); // Add this line
  }

  initializeStatsModal() {
    const statsButton = document.getElementById('stats-button');
    const statsModal = document.getElementById('stats-modal');
    const closeStatsButton = document.getElementById('close-stats-modal');

    // Stats button opens modal
    statsButton.addEventListener('click', () => {
      statsModal.classList.add('active');
      this.updateStatsDisplay(); // Update stats when opening modal
    });

    // Close button closes modal
    closeStatsButton.addEventListener('click', () => {
      statsModal.classList.remove('active');
    });

    // Clicking outside modal closes it
    statsModal.addEventListener('click', (e) => {
      if (e.target === statsModal) {
        statsModal.classList.remove('active');
      }
    });
  }

  initializeSettings() {
    // Settings button functionality
    const settingsButton = document.getElementById('settings-button');
    const settingsModal = document.getElementById('settings-modal');
    const closeSettingsButton = document.getElementById('close-settings-modal');
    
    // Get the toggle switches
    const particlesToggle = document.getElementById('particles-toggle');
    const playlogToggle = document.getElementById('playlog-toggle');
    
    // Load saved settings from localStorage
    const savedSettings = JSON.parse(localStorage.getItem('tictactoe-settings') || '{"particles": true, "playlog": true}');
    
    // Apply saved settings
    particlesToggle.checked = savedSettings.particles;
    playlogToggle.checked = savedSettings.playlog;
    
    // Apply initial states
    const particlesContainer = document.getElementById('particles-container');
    const playLog = document.querySelector('.play-log');
    
    particlesContainer.style.display = savedSettings.particles ? 'block' : 'none';
    playLog.style.display = savedSettings.playlog ? 'block' : 'none';
    
    // Add event listeners for settings toggles
    particlesToggle.addEventListener('change', (e) => {
      particlesContainer.style.display = e.target.checked ? 'block' : 'none';
      saveSettings();
    });
    
    playlogToggle.addEventListener('change', (e) => {
      playLog.style.display = e.target.checked ? 'block' : 'none';
      saveSettings();
    });
    
    // Settings modal controls
    settingsButton.addEventListener('click', () => {
      settingsModal.classList.add('active');
    });
    
    closeSettingsButton.addEventListener('click', () => {
      settingsModal.classList.remove('active');
    });
    
    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) {
        settingsModal.classList.remove('active');
      }
    });
    
    // Function to save settings to localStorage
    const saveSettings = () => {
      const settings = {
        particles: particlesToggle.checked,
        playlog: playlogToggle.checked
      };
      localStorage.setItem('tictactoe-settings', JSON.stringify(settings));
    };
  }

  loadStats() {
    const savedStats = localStorage.getItem('tictactoe-stats');
    return savedStats ? JSON.parse(savedStats) : {
      wins: 0,
      losses: 0
    };
  }

  saveStats() {
    localStorage.setItem('tictactoe-stats', JSON.stringify(this.stats));
  }

  updateStatsDisplay() {
    document.getElementById('wins-count').textContent = this.stats.wins;
    document.getElementById('losses-count').textContent = this.stats.losses;
  }

  createParticles() {
    const container = document.getElementById('particles-container');
    const numParticles = 20; // Number of each type (X and O)
    
    for (let i = 0; i < numParticles * 2; i++) {
      const particle = document.createElement('div');
      particle.className = `particle ${i < numParticles ? 'x' : 'o'}`;
      particle.textContent = i < numParticles ? 'X' : 'O';
      
      // Random starting position
      particle.style.left = `${Math.random() * 100}vw`;
      particle.style.top = `${Math.random() * 100}vh`;
      
      // Random animation delay
      particle.style.animationDelay = `${Math.random() * 8}s`;
      
      container.appendChild(particle);
    }
  }

  createBoard() {
    const superBoard = document.getElementById('super-board');
    superBoard.innerHTML = '';
    
    for (let i = 0; i < 9; i++) {
      const subBoard = document.createElement('div');
      subBoard.className = 'sub-board';
      subBoard.dataset.board = i; // Store board index

      const isBoardFull = !this.superBoard[i].includes('');
      const hasWinner = this.subBoardWinners[i];
      
      // Add hover events for boards that have been won
      if (hasWinner || isBoardFull) {
        subBoard.addEventListener('mouseenter', () => {
          // Remove flipping class to show grid
          subBoard.classList.remove('flipping');
          
          // Recreate cells with the stored state
          const boardState = this.superBoard[i];
          
          // Clear existing cells
          const cells = subBoard.querySelectorAll('.cell');
          cells.forEach(cell => cell.remove());
          
          // Recreate cells with the stored state
          for (let j = 0; j < 9; j++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.board = i;
            cell.dataset.cell = j;
            
            if (boardState[j]) {
              cell.classList.add(boardState[j].toLowerCase());
              cell.textContent = boardState[j];
            }
            
            // Insert cell before the winner symbol
            const winnerSymbol = subBoard.querySelector('.winner-symbol');
            subBoard.insertBefore(cell, winnerSymbol);
          }
        });

        subBoard.addEventListener('mouseleave', () => {
          // Remove temporary cells
          const cells = subBoard.querySelectorAll('.cell');
          cells.forEach(cell => cell.remove());
          
          // Add back flipping class
          subBoard.classList.add('flipping');
        });
      }

      if (!hasWinner && !isBoardFull) {
        for (let j = 0; j < 9; j++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.board = i;
          cell.dataset.cell = j;
          
          if (this.superBoard[i][j]) {
            cell.classList.add(this.superBoard[i][j].toLowerCase());
            cell.textContent = this.superBoard[i][j];
          }
          
          subBoard.appendChild(cell);
        }
      }

      const winnerSymbol = document.createElement('div');
      winnerSymbol.className = 'winner-symbol';
      
      if (hasWinner) {
        winnerSymbol.classList.add(this.subBoardWinners[i].toLowerCase());
        winnerSymbol.textContent = this.subBoardWinners[i];
        subBoard.classList.add('flipping');
        subBoard.classList.add(`won-${this.subBoardWinners[i].toLowerCase()}`);
      } else if (isBoardFull) {
        winnerSymbol.classList.add('draw');
        winnerSymbol.textContent = '~';
        subBoard.classList.add('flipping');
        subBoard.classList.add('won-draw');
      }
      
      subBoard.appendChild(winnerSymbol);
      
      if (this.activeBoard !== -1 && this.activeBoard !== i && !this.gameWinner && !hasWinner && !isBoardFull) {
        subBoard.classList.add('inactive');
      }
      
      if ((this.activeBoard === -1 || this.activeBoard === i) && !this.gameWinner) {
        if (!this.subBoardWinners[i] && !isBoardFull) {
          subBoard.classList.add('active');
        }
      }
      
      superBoard.appendChild(subBoard);
    }
  }

  addEventListeners() {
    document.getElementById('super-board').addEventListener('click', (e) => {
      if (!e.target.classList.contains('cell')) return;
      if (this.currentPlayer === 'O' || this.gameWinner) return;
      
      const boardIndex = parseInt(e.target.dataset.board);
      const cellIndex = parseInt(e.target.dataset.cell);
      
      this.makeMove(boardIndex, cellIndex);
    });

    document.getElementById('reset').addEventListener('click', () => {
      const modal = document.getElementById('new-game-modal');
      modal.classList.add('active');
    });

    document.getElementById('start-game').addEventListener('click', () => {
      const modal = document.getElementById('new-game-modal');
      modal.classList.remove('active');
      this.resetGame();
    });

    document.getElementById('difficulty').addEventListener('change', (e) => {
      // Only store the selected difficulty, don't apply it yet
      this.initialDifficulty = e.target.value;
      // Don't update the display or current difficulty until new game starts
    });

    document.getElementById('close-modal').addEventListener('click', () => {
      const modal = document.getElementById('new-game-modal');
      modal.classList.remove('active');
    });

    document.getElementById('new-game-modal').addEventListener('click', (e) => {
      if (e.target.id === 'new-game-modal') {
        const modal = document.getElementById('new-game-modal');
        modal.classList.remove('active');
      }
    });
  }

  updateDifficultyDisplay() {
    const difficultyDisplay = document.getElementById('difficulty-display');
    const displayText = this.difficulty.charAt(0).toUpperCase() + this.difficulty.slice(1);
    difficultyDisplay.textContent = `Bot Difficulty: ${displayText}`;
  }

  addMoveToLog(player, boardIndex, cellIndex) {
    const moveText = `${player} played in board ${boardIndex + 1}, cell ${cellIndex + 1}`;
    this.moveLog.push({
      player,
      boardIndex,
      cellIndex,
      text: moveText
    });
    this.updateMoveLog();
  }

  updateMoveLog() {
    const logContainer = document.getElementById('log-entries');
    logContainer.innerHTML = '';
    
    this.moveLog.slice().reverse().forEach((move) => {
      const entry = document.createElement('div');
      
      if (move.type === 'new-game') {
        entry.className = 'log-entry new-game';
      } else {
        entry.className = `log-entry ${move.player.toLowerCase()}-move`;
      }
      
      entry.textContent = move.text;
      
      if (move.boardIndex !== undefined && move.cellIndex !== undefined) {
        entry.addEventListener('mouseenter', () => {
          const subBoard = document.querySelector(`.sub-board[data-board="${move.boardIndex}"]`);
          if (subBoard) {
            // Remove flipping class to show grid
            subBoard.classList.remove('flipping');
            
            // Temporarily bring back all cells if they were removed
            if (this.subBoardWinners[move.boardIndex]) {
              // Store current board state
              const boardState = this.superBoard[move.boardIndex];
              
              // Clear existing cells
              const cells = subBoard.querySelectorAll('.cell');
              cells.forEach(cell => cell.remove());
              
              // Recreate cells with the stored state
              for (let j = 0; j < 9; j++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.board = move.boardIndex;
                cell.dataset.cell = j;
                
                if (boardState[j]) {
                  cell.classList.add(boardState[j].toLowerCase());
                  cell.textContent = boardState[j];
                }
                
                // Add highlight class to the specific move
                if (j === move.cellIndex) {
                  cell.classList.add('highlight');
                }
                
                // Insert cell before the winner symbol
                const winnerSymbol = subBoard.querySelector('.winner-symbol');
                subBoard.insertBefore(cell, winnerSymbol);
              }
            } else {
              // For non-won boards, just add highlight to the existing cell
              const cell = document.querySelector(
                `.cell[data-board="${move.boardIndex}"][data-cell="${move.cellIndex}"]`
              );
              if (cell) {
                cell.classList.add('highlight');
              }
            }
          }
        });
        
        entry.addEventListener('mouseleave', () => {
          const subBoard = document.querySelector(`.sub-board[data-board="${move.boardIndex}"]`);
          if (subBoard) {
            if (this.subBoardWinners[move.boardIndex]) {
              // Remove temporary cells
              const cells = subBoard.querySelectorAll('.cell');
              cells.forEach(cell => cell.remove());
              
              // Add back flipping class
              subBoard.classList.add('flipping');
            } else {
              // For non-won boards, just remove highlight from the existing cell
              const cell = document.querySelector(
                `.cell[data-board="${move.boardIndex}"][data-cell="${move.cellIndex}"]`
              );
              if (cell) {
                cell.classList.remove('highlight');
              }
            }
          }
        });
      }
      
      logContainer.appendChild(entry);
    });
  }

  makeMove(boardIndex, cellIndex) {
    if (this.gameWinner) return;
    if (this.subBoardWinners[boardIndex]) return;
    if (this.activeBoard !== -1 && boardIndex !== this.activeBoard) return;
    if (this.superBoard[boardIndex][cellIndex]) return;

    this.superBoard[boardIndex][cellIndex] = this.currentPlayer;
    this.addMoveToLog(this.currentPlayer, boardIndex, cellIndex);
    
    const winner = this.checkWin(this.superBoard[boardIndex]);
    if (winner || !this.superBoard[boardIndex].includes('')) {
      this.subBoardWinners[boardIndex] = winner || '~';
      const superWinResult = this.checkWinWithLine(this.subBoardWinners);
      
      if (superWinResult) {
        this.gameWinner = superWinResult.winner;
        this.updateStatus(`${this.gameWinner} Wins the Game!`);
        this.aiThinkingIndicator.classList.add('fade-out');
        this.createBoard();
        if (this.gameWinner === 'X') {
          this.stats.wins++;
          this.saveStats();
          this.playConfetti();
        } else if (this.gameWinner === 'O') {
          this.stats.losses++;
          this.saveStats();
        }
        return;
      } else if (!this.subBoardWinners.includes('') && !this.gameWinner) {
        this.gameWinner = 'DRAW';
        const status = document.getElementById('status');
        status.textContent = "Game is a Draw!";
        status.style.color = '#f0883e';
        this.aiThinkingIndicator.classList.add('fade-out');
        this.createBoard();
        return;
      }
    }

    this.activeBoard = this.subBoardWinners[cellIndex] ? -1 : cellIndex;
    this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
    this.updateStatus();
    this.createBoard();

    this.aiThinkingIndicator.classList.toggle('fade-out', this.currentPlayer === 'X');

    if (this.currentPlayer === 'O' && !this.gameWinner) {
      setTimeout(() => this.makeAIMove(), 500);
    }
  }

  checkWinWithLine(board) {
    const lines = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8],
      [0, 3, 6], [1, 4, 7], [2, 5, 8],
      [0, 4, 8], [2, 4, 6]
    ];

    for (let line of lines) {
      const [a, b, c] = line;
      if (board[a] && board[a] !== '~' && board[a] === board[b] && board[a] === board[c]) {
        return {
          winner: board[a],
          line: line
        };
      }
    }
    
    return null;
  }

  checkWin(board) {
    const result = this.checkWinWithLine(board);
    return result ? result.winner : null;
  }

  isWinningMove(boardIndex, cellIndex, player) {
    this.superBoard[boardIndex][cellIndex] = player;
    const result = this.checkWin(this.superBoard[boardIndex]);
    this.superBoard[boardIndex][cellIndex] = '';
    return result === player;
  }

  createsFork(boardIndex, cellIndex, player) {
    this.superBoard[boardIndex][cellIndex] = player;
    let winningLines = 0;
    const lines = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8],
      [0, 3, 6], [1, 4, 7], [2, 5, 8],
      [0, 4, 8], [2, 4, 6]
    ];

    for (let line of lines) {
      let playerCount = 0;
      let emptyCount = 0;
      
      for (let pos of line) {
        if (this.superBoard[boardIndex][pos] === player) playerCount++;
        if (this.superBoard[boardIndex][pos] === '') emptyCount++;
      }
      
      if (playerCount === 2 && emptyCount === 1) winningLines++;
    }
    
    this.superBoard[boardIndex][cellIndex] = '';
    return winningLines >= 2;
  }

  makeAIMove() {
    if (this.difficulty === 'easy') {
      this.makeRandomMove();
    } else if (this.difficulty === 'medium') {
      this.makeMediumMove();
    } else if (this.difficulty === 'hard') {
      this.makeHardMove();
    } else if (this.difficulty === 'insane') {
      this.makeInsaneMove();
    }
  }

  makeRandomMove() {
    const availableMoves = this.getAvailableMoves();
    if (availableMoves.length > 0) {
      const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
      this.makeMove(randomMove.boardIndex, randomMove.cellIndex);
    }
  }

  makeMediumMove() {
    const availableMoves = this.getAvailableMoves();
    
    for (const move of availableMoves) {
      if (this.isWinningMove(move.boardIndex, move.cellIndex, 'O')) {
        this.makeMove(move.boardIndex, move.cellIndex);
        return;
      }
    }
    
    for (const move of availableMoves) {
      if (this.isWinningMove(move.boardIndex, move.cellIndex, 'X')) {
        this.makeMove(move.boardIndex, move.cellIndex);
        return;
      }
    }
    
    this.makeRandomMove();
  }

  makeHardMove() {
    const availableMoves = this.getAvailableMoves();
    
    for (const move of availableMoves) {
      if (this.isWinningMove(move.boardIndex, move.cellIndex, 'O')) {
        this.makeMove(move.boardIndex, move.cellIndex);
        return;
      }
    }
    
    for (const move of availableMoves) {
      if (this.isWinningMove(move.boardIndex, move.cellIndex, 'X')) {
        this.makeMove(move.boardIndex, move.cellIndex);
        return;
      }
    }
    
    for (const move of availableMoves) {
      if (this.createsFork(move.boardIndex, move.cellIndex, 'O')) {
        this.makeMove(move.boardIndex, move.cellIndex);
        return;
      }
    }
    
    for (const move of availableMoves) {
      if (this.createsFork(move.boardIndex, move.cellIndex, 'X')) {
        this.makeMove(move.boardIndex, move.cellIndex);
        return;
      }
    }
    
    const centerMove = availableMoves.find(move => move.cellIndex === 4);
    if (centerMove) {
      this.makeMove(centerMove.boardIndex, centerMove.cellIndex);
      return;
    }
    
    const cornerMove = availableMoves.find(move => [0,2,6,8].includes(move.cellIndex));
    if (cornerMove) {
      this.makeMove(cornerMove.boardIndex, cornerMove.cellIndex);
      return;
    }
    
    this.makeRandomMove();
  }

  makeInsaneMove() {
    const availableMoves = this.getAvailableMoves();
    let bestMove = null;
    let bestScore = -Infinity;
    
    for (const move of availableMoves) {
      this.superBoard[move.boardIndex][move.cellIndex] = 'O';
      const score = this.minimax(move.boardIndex, move.cellIndex, 5, -Infinity, Infinity, false);
      this.superBoard[move.boardIndex][move.cellIndex] = '';
      
      if (score > bestScore) {
        bestScore = score;
        bestMove = move;
      }
    }
    
    if (bestMove) {
      this.makeMove(bestMove.boardIndex, bestMove.cellIndex);
    } else {
      this.makeRandomMove();
    }
  }

  minimax(boardIndex, cellIndex, depth, alpha, beta, isMaximizing) {
    if (depth === 0) {
      return this.evaluatePosition();
    }
    
    const winner = this.checkWin(this.superBoard[boardIndex]);
    if (winner) {
      return winner === 'O' ? 100 : -100;
    }
    
    const nextBoard = this.subBoardWinners[cellIndex] ? -1 : cellIndex;
    const availableMoves = this.getAvailableMoves(nextBoard);
    
    if (isMaximizing) {
      let maxEval = -Infinity;
      for (const move of availableMoves) {
        this.superBoard[move.boardIndex][move.cellIndex] = 'O';
        const evaluation = this.minimax(move.boardIndex, move.cellIndex, depth - 1, alpha, beta, false);
        this.superBoard[move.boardIndex][move.cellIndex] = '';
        maxEval = Math.max(maxEval, evaluation);
        alpha = Math.max(alpha, evaluation);
        if (beta <= alpha) break;
      }
      return maxEval;
    } else {
      let minEval = Infinity;
      for (const move of availableMoves) {
        this.superBoard[move.boardIndex][move.cellIndex] = 'X';
        const evaluation = this.minimax(move.boardIndex, move.cellIndex, depth - 1, alpha, beta, true);
        this.superBoard[move.boardIndex][move.cellIndex] = '';
        minEval = Math.min(minEval, evaluation);
        beta = Math.min(beta, evaluation);
        if (beta <= alpha) break;
      }
      return minEval;
    }
  }

  evaluatePosition() {
    let score = 0;
    for (let i = 0; i < 9; i++) {
      if (this.subBoardWinners[i] === 'O') score += 10;
      if (this.subBoardWinners[i] === 'X') score -= 10;
    }
    return score;
  }

  getAvailableMoves(specificBoard = null) {
    const moves = [];
    const validBoards = specificBoard === null ? 
      (this.activeBoard === -1 ? Array.from({length: 9}, (_, i) => i) : [this.activeBoard]) :
      (specificBoard === -1 ? Array.from({length: 9}, (_, i) => i) : [specificBoard]);

    for (const boardIndex of validBoards) {
      if (this.subBoardWinners[boardIndex]) continue;
      for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
        if (!this.superBoard[boardIndex][cellIndex]) {
          moves.push({boardIndex, cellIndex});
        }
      }
    }
    return moves;
  }

  resetGame() {
    this.currentPlayer = 'X';
    this.superBoard = Array(9).fill().map(() => Array(9).fill(''));
    this.subBoardWinners = Array(9).fill('');
    this.activeBoard = -1;
    this.gameWinner = null;
    
    this.moveLog = [{
      text: "New game started",
      type: "new-game"
    }];
    
    this.difficulty = this.initialDifficulty;
    this.updateDifficultyDisplay();
    this.updateMoveLog();
    this.updateStatus();
    this.createBoard();
    this.aiThinkingIndicator.classList.add('fade-out'); 
  }

  updateStatus(message) {
    const status = document.getElementById('status');
    status.textContent = message || `${this.currentPlayer}'s Turn`;
    if (this.activeBoard !== -1 && !this.gameWinner) {
      status.textContent += ` (Board ${this.activeBoard + 1})`;
    }
    status.className = this.currentPlayer === 'X' ? 'x-turn' : 'o-turn';
  }

  playConfetti() {
    const duration = 3000;
    const animationEnd = Date.now() + duration;
    const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 };

    function randomInRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    const interval = setInterval(function() {
      const timeLeft = animationEnd - Date.now();

      if (timeLeft <= 0) {
        return clearInterval(interval);
      }

      const particleCount = 50 * (timeLeft / duration);
      
      confetti({
        ...defaults,
        particleCount,
        origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
      });
      confetti({
        ...defaults,
        particleCount,
        origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
      });
    }, 250);
  }
}

document.addEventListener('DOMContentLoaded', () => {
  new SuperTicTacToe();
});
</script>
</body></html>